package Scrapper;

import Items.FolkLore_Fishing;
import Items.FolkLore_Node;
import Items.Regular_Node;
import Items.Unspoiled_Node;

import java.io.*;
import java.rmi.UnexpectedException;

import static Scrapper.StaticItemTypes.*;

/**
 * Puts an ITEM tag infront of each item for ease of reading.
 */
public class Formatter {
    private File file;//File to read/write
    private StaticItemTypes itemType; //Current Enum Item Type

    /**
     * Default constructor, should be the only one needed.
     * @param file File to run on.
     */
    Formatter(File file){
        this.file = file;
    }

    /**
     * A helper method for format()
     * Looks at current line, if is a header that describes an item type, sets global var itemType to whatever that current item is.
     * If it is not an item, such as an ending header, or is data, it will return either Delete, or Ignore where Ignore = data.
     * @param curLine Current line to look at
     * @return One of the StaticItemTypes
     */
    private StaticItemTypes setCurrentType(String curLine){
        switch (curLine) {
            case "Folklore Tome\tTime\tItem\tSlot\tLocation\tCoordinates\tUsed to make\n" -> {
                itemType = FolkLoreNode;
                return FolkLoreNode;
            }
            case "Folklore Tome\tTime\tItem\tLocation\tCoordinates\tAdditional Info\n" -> {
                itemType = FolkLoreFishing;
                return FolkLoreFishing;
            }
            case "Level\tType\tZone\tCoordinate\tItems\tExtra\n" -> {
                itemType = RegularNode;
                return RegularNode;
            }
            case "Time\tItem\tSlot #\tLocation\tCoordinate\tLevel\tStar\tAdditional Info\n", "Time\tItem\tSlot #\tLocation\tCoordinate\tExtra\tStar\n" -> {
                itemType = UnspoiledNode;
                return UnspoiledNode;
            }


            //Ignore cases below possible checkme?
            case "Regular Nodes Unspoiled Nodes Ephemeral Nodes Folklore Nodes\tRegular Nodes Unspoiled Nodes Ephemeral Nodes Folklore Nodes\tFishing Log Big Fishing Fishing Collectables Folklore Fish\n", "Botanist\tMiner\tFisher\n", "Gathering" -> {
                return Delete;
            }
        }
        return Ignore;
    }

    /**
     * A helper method to format().
     * itemType Determined from an item return value when setCurrentType returns Ignore (data to extract). (See StaticItemTypes method)
     * @param csvValues Current line loaded in, delimited by \t
     * @return New line that should replace the old line.
     */
    private String formattedItem(String[] csvValues){//fixme
        StringBuilder FormattedItem = new StringBuilder(); //String to replace the current line read in

        switch (itemType){
            case RegularNode:{
                //Per each item found, append a new item to the list
                csvValues[5].split(",");

                FormattedItem.append(RegularNode.name());//Appends the name of the item first
                FormattedItem.append("\t");
                FormattedItem.append(new Regular_Node(,
                        csvValues[5],//item
                        csvValues[2],//zone
                        csvValues[3],//cords
                        csvValues[5],//extra
                        csvValues[0],//level
                        csvValues[1]//Type
                ).toString());
            }//todo, this is a little more complicated (see todoist)
            case FolkLoreNode:{
                FormattedItem.append(FolkLoreNode.name());
                FormattedItem.append("\t");
                FormattedItem.append(new FolkLore_Node(
                        csvValues[2],//Item
                        csvValues[4],//zone
                        csvValues[5],//cords
                        csvValues[6],//AddInfo (end of baseItem)
                        csvValues[0],//FolkLoreTome
                        csvValues[1],//Time
                        Integer.parseInt(csvValues[3])//Slot
                ).toString());
            }
            case FolkLoreFishing:{
                FormattedItem.append(FolkLoreFishing.name());
                FormattedItem.append("\t");
                FormattedItem.append(new FolkLore_Fishing(
                        csvValues[2],//Item
                        csvValues[3],//zone
                        csvValues[4],//cords
                        csvValues[5],//AddInfo (end of baseItem)
                        csvValues[1],//Time
                        csvValues[0]//FolkLoreTome
                ).toString());

            }
            case UnspoiledNode:{
                //Dealing with no level value (ARR case)
                if(csvValues[5] == null){ //If no level value then put -1 fixme pretty sure this doesnt work
                    csvValues[5] = String.valueOf(-1);
                }

                //Now finding the number of stars ( csvValues[6] )
                int tmpStarCounter = 0;
                for(int i=0;i< csvValues[6].length();i++){
                    if(csvValues[6].charAt(i) == '★') tmpStarCounter++;
                }
                csvValues[6] = String.valueOf(tmpStarCounter);

                //Finally loading in the item
                FormattedItem.append(UnspoiledNode.name());
                FormattedItem.append("\t");
                FormattedItem.append(new Unspoiled_Node(
                        csvValues[1],//Item
                        csvValues[3],//zone
                        csvValues[4],//cords
                        csvValues[7],//addInfo (end of baseItem)
                        csvValues[0],//time
                        Integer.parseInt(csvValues[2]), //slot
                        Integer.parseInt(csvValues[5]),//level
                        Integer.parseInt(csvValues[6]) //star todo, deal with counting # of stars by taking # of ★
                ).toString()
                );
            }
        } //End of switch case
        return FormattedItem.toString();
    }

    /**
     * Formats the file by:
     * Goes through line by line.
     * [StaticItemTypes Method]
     * Searches for table HEADERS in wiki which determines the current ITEMTYPE (internal var). This is obtained from the StaticItemTypes method.
     * Eg. Gather header -> each item is now a Gather item.
     *
     * When a data line is found (normal table values) will execute
     * [obtainItemString Method]
     * This will format the current line according to the ITEMTYPE.
     *
     * Then this method will replace the current line
     *
     * Reads line by line with a Buffered reader and writer, putts into queue, and replaces each line.
     * This method creates several duplicate items and has another method called later on.
     */
    public void formatFile(){
        //todo Replace current line in file. Eventually, make all ITEMs in the first column for ease of fuzzy Search
        try {
            BufferedReader br = new BufferedReader(new FileReader(file));
            BufferedWriter bw = new BufferedWriter(new FileWriter(file));
            String currentLine; //Current line
            String[] csvValues;//Current line read in as CSV in an array

            while((currentLine = br.readLine()) != null){
                csvValues = currentLine.split("\t",-1); //Load all values into an array. Used to normalize iteems

                switch (setCurrentType(currentLine)) { //Cases to find item type
                    //If header: Set a new ItemType
                    //Else if data, use cur item type.
                    case FolkLoreFishing, FolkLoreNode, RegularNode, UnspoiledNode, Delete -> {
                        //todo delete current line
                        continue;
                    }
                    case Ignore -> { //Actual item data NOT a header
                        formattedItem(csvValues);
                        //todo Finally, replace current line with the FormattedItem string
                        continue;
                    }
                }//End of switch statement
                throw new UnexpectedException("No item type was assigned!"); //An item type should always be caught by the switch case
            }//End of while statement
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    public void SortByItemName(){

        /*
        //should sort file by item name, MUST be run after being formatted.
        //Should I load the whole entire file into an arraylist/array and take
        //up a massivea mnt of memory? It's only run once so shuld b fine?
         */
    }

    //setters

    /**
     * Sets the object to run on a new file. (Constructor forces a file by default).
     * @param file New file to run on
     */
    public void setFile(File file) {
        this.file = file;
    }

    /**
     * Gets current file running
     * @return Current instanced FILE object.
     */
    public File getFile() {
        return file;
    }
}